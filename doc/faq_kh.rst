.. _faq:

=================
សំណួរ​ដែលគេ​ច្រើន​សួរ
=================

.. currentmodule : : sklearn

នៅទីនេះយើងព្យាយាមផ្តល់ចម្លើយមួយចំនួនចំពោះសំណួរដែលលេចឡើងជាទៀងទាត់នៅលើបញ្ជីសំបុត្ររួម។

តារាង​មាតិកា

អំពីគម្រោង
តើគម្រោងឈ្មោះអ្វី (មនុស្សជាច្រើនយល់ខុស)?
តើអ្នកប្រកាសឈ្មោះគម្រោងដោយរបៀបណា?
ហេតុអ្វីបានជា scikit?
តើអ្នកគាំទ្រ PyPy ទេ?
ការសម្រេចចិត្តអនុវត្ត
ហេតុអ្វីបានជាមិនមានការគាំទ្រសម្រាប់ការរៀនស៊ីជម្រៅ ឬពង្រឹងបន្ថែម / តើនឹងមានការគាំទ្រសម្រាប់ការរៀនជ្រៅ ឬពង្រឹងនៅក្នុង scikit-learn?
តើអ្នកនឹងបន្ថែមគំរូក្រាហ្វិក ឬការទស្សន៍ទាយតាមលំដាប់ទៅ scikit-learn ទេ?
ហេតុអ្វីបានជាអ្នកលុប HMMs ចេញពី scikit-learn?
តើអ្នកនឹងបន្ថែមការគាំទ្រ GPU ទេ?
ហេតុអ្វីបានជាអថេរ categorical ត្រូវការដំណើរការជាមុននៅក្នុង scikit-learn បើប្រៀបធៀបទៅនឹងឧបករណ៍ផ្សេងទៀត?
ហេតុអ្វីបានជា Scikit-learn មិនដំណើរការដោយផ្ទាល់ជាមួយឧទាហរណ៍ pandas.DataFrame?
តើអ្នកមានគម្រោងអនុវត្តការបំប្លែងសម្រាប់គោលដៅ y នៅក្នុងបំពង់ទេ?
ហេតុអ្វីបានជាមានការប៉ាន់ប្រមាណខុសៗគ្នាជាច្រើនសម្រាប់ម៉ូដែលលីនេអ៊ែរ?
ការរួមចំណែក
តើខ្ញុំអាចចូលរួមចំណែកក្នុងការរៀន scikit យ៉ាងដូចម្តេច?
ហេតុអ្វីបានជាសំណើរទាញរបស់ខ្ញុំមិនទទួលបានការចាប់អារម្មណ៍?
តើអ្វីជាលក្ខណៈវិនិច្ឆ័យនៃការដាក់បញ្ចូលសម្រាប់ក្បួនដោះស្រាយថ្មី?
ហេតុអ្វី​បាន​ជា​អ្នក​ជ្រើសរើស​យ៉ាង​ខ្លាំង​លើ​អ្វី​ដែល​អ្នក​បញ្ចូល​ក្នុង​ក្បួន​ដោះស្រាយ​ក្នុង​ការ​សិក្សា scikit-learn?
ការប្រើប្រាស់ scikit-learn
តើអ្វីជាវិធីល្អបំផុតដើម្បីទទួលបានជំនួយលើការប្រើប្រាស់ scikit-learn?
តើខ្ញុំគួររក្សាទុក នាំចេញ ឬដាក់ពង្រាយការប៉ាន់ប្រមាណសម្រាប់ផលិតកម្មយ៉ាងដូចម្តេច?
តើខ្ញុំអាចបង្កើតវត្ថុបណ្តុំដោយរបៀបណា?
តើខ្ញុំអាចផ្ទុកសំណុំទិន្នន័យផ្ទាល់ខ្លួនរបស់ខ្ញុំទៅជាទម្រង់ដែលអាចប្រើបានដោយ scikit-learn យ៉ាងដូចម្តេច?
តើខ្ញុំដោះស្រាយជាមួយទិន្នន័យខ្សែអក្សរ (ឬដើមឈើ ក្រាហ្វ...) យ៉ាងដូចម្តេច?
ហេតុអ្វីបានជាពេលខ្លះខ្ញុំមានការគាំង/បង្កកជាមួយ n_jobs> 1 នៅក្រោម OSX ឬ Linux?
ហេតុអ្វីបានជាការងាររបស់ខ្ញុំប្រើស្នូលច្រើនជាងអ្វីដែលបានបញ្ជាក់ជាមួយ n_jobs?
តើខ្ញុំកំណត់ Random_state សម្រាប់ការប្រតិបត្តិទាំងមូលដោយរបៀបណា?

អំពីគម្រោង
តើគម្រោងឈ្មោះអ្វី (មនុស្សជាច្រើនយល់ខុស)?
scikit-learn ប៉ុន្តែមិនមែន scikit ឬ SciKit ឬ sci-kit រៀនទេ។ ក៏មិនមែន scikits.learn ឬ scikits-learn ដែលធ្លាប់ប្រើពីមុនដែរ។

តើអ្នកប្រកាសឈ្មោះគម្រោងដោយរបៀបណា?
sy-kit រៀន។ sci តំណាងឱ្យវិទ្យាសាស្ត្រ!

ហេតុអ្វីបានជា scikit?
មាន scikits ជាច្រើន ដែលជាប្រអប់ឧបករណ៍វិទ្យាសាស្រ្តដែលបង្កើតឡើងនៅជុំវិញ SciPy ។ ក្រៅពី scikit-learn ការពេញនិយមមួយទៀតគឺ scikit-image ។

តើអ្នកគាំទ្រ PyPy ទេ?
scikit-learn ត្រូវបានសាកល្បង និងរក្សាជាប្រចាំដើម្បីធ្វើការជាមួយ PyPy (ការអនុវត្ត Python ជំនួសជាមួយកម្មវិធីចងក្រងដែលភ្ជាប់មកជាមួយក្នុងពេលតែមួយ)។

ទោះជាយ៉ាងណាក៏ដោយ ចំណាំថាការគាំទ្រនេះនៅតែត្រូវបានចាត់ទុកថាជាការពិសោធន៍ ហើយសមាសធាតុជាក់លាក់អាចមានឥរិយាបទខុសគ្នាបន្តិច។ សូមមើលឈុតសាកល្បងនៃម៉ូឌុលជាក់លាក់នៃការចាប់អារម្មណ៍សម្រាប់ព័ត៌មានលម្អិតបន្ថែម។

ការសម្រេចចិត្តអនុវត្ត
ហេតុអ្វីបានជាមិនមានការគាំទ្រសម្រាប់ការរៀនស៊ីជម្រៅ ឬពង្រឹងបន្ថែម / តើនឹងមានការគាំទ្រសម្រាប់ការរៀនជ្រៅ ឬពង្រឹងនៅក្នុង scikit-learn?
ការរៀនស៊ីជម្រៅ និងការរៀនពង្រឹងទាំងពីរទាមទារវាក្យសព្ទដ៏សម្បូរបែបដើម្បីកំណត់ស្ថាបត្យកម្ម ដោយការសិក្សាស៊ីជម្រៅបន្ថែមលើតម្រូវការ GPU សម្រាប់ការគណនាប្រកបដោយប្រសិទ្ធភាព។ ទោះយ៉ាងណាក៏ដោយ ទាំងពីរនេះមិនសមនៅក្នុងឧបសគ្គនៃការរចនានៃ scikit-learn; ជាលទ្ធផល ការរៀនស៊ីជម្រៅ និងការរៀនពង្រឹងបច្ចុប្បន្នគឺនៅក្រៅវិសាលភាពសម្រាប់អ្វីដែល scikit-learn ស្វែងរកដើម្បីសម្រេចបាន។

អ្នកអាចស្វែងរកព័ត៌មានបន្ថែមអំពីការបន្ថែមការគាំទ្រ gpu នៅ Will you add GPU support?.

ចំណាំថា scikit-learn បច្ចុប្បន្នអនុវត្ត perceptron ពហុស្រទាប់សាមញ្ញនៅក្នុង :mod:`sklearn.neural_network`។ យើងនឹងទទួលយកតែការកែកំហុសសម្រាប់ម៉ូឌុលនេះប៉ុណ្ណោះ។ ប្រសិនបើ​អ្នក​ចង់​អនុវត្ត​គំរូ​សិក្សា​ជ្រៅជ្រះ​កាន់តែ​ស្មុគស្មាញ សូម​ងាក​ទៅ​រក​ក្របខ័ណ្ឌ​សិក្សា​ជ្រៅជ្រះ​ដ៏ពេញនិយម​ដូចជា tensorflow, keras និង pytorch។

តើអ្នកនឹងបន្ថែមគំរូក្រាហ្វិក ឬការទស្សន៍ទាយតាមលំដាប់ទៅ scikit-learn ទេ?
មិន​មាន​នៅ​ពេល​អនាគត​ដែល​អាច​មើល​ឃើញ​។ scikit-learn ព្យាយាមផ្តល់នូវ API បង្រួបបង្រួមសម្រាប់កិច្ចការមូលដ្ឋានក្នុងការរៀនម៉ាស៊ីន ដោយមានបំពង់បង្ហូរប្រេង និងមេតា-algorithms ដូចជាការស្វែងរកក្រឡាចត្រង្គ ដើម្បីភ្ជាប់អ្វីៗគ្រប់យ៉ាងជាមួយគ្នា។ គោលគំនិតដែលត្រូវការ APIs ក្បួនដោះស្រាយ និងជំនាញដែលត្រូវការសម្រាប់ការរៀនដែលមានរចនាសម្ព័ន្ធគឺខុសពីអ្វីដែល scikit-learn មានផ្តល់ជូន។ ប្រសិនបើយើងចាប់ផ្តើមធ្វើការសិក្សាដែលមានរចនាសម្ព័ន្ធតាមអំពើចិត្ត យើងត្រូវរចនាកញ្ចប់ទាំងមូលឡើងវិញ ហើយគម្រោងនេះទំនងជានឹងដួលរលំនៅក្រោមទម្ងន់របស់វា។

មានគម្រោងពីរដែលមាន API ស្រដៀងនឹង scikit-learn ដែលធ្វើការទស្សន៍ទាយតាមរចនាសម្ព័ន្ធ៖

pystruct គ្រប់គ្រងការរៀនដែលមានរចនាសម្ព័ន្ធទូទៅ (ផ្តោតលើ SSVMs លើរចនាសម្ព័ន្ធក្រាហ្វដែលបំពានជាមួយនឹងការសន្និដ្ឋានប្រហាក់ប្រហែល; កំណត់សញ្ញាណនៃគំរូជាឧទាហរណ៍នៃរចនាសម្ព័ន្ធក្រាហ្វ)
seqlearn គ្រប់គ្រងតែលំដាប់ប៉ុណ្ណោះ (ផ្តោតលើការសន្និដ្ឋានពិតប្រាកដ មាន HMMs ប៉ុន្តែភាគច្រើនសម្រាប់ភាពពេញលេញ ចាត់ទុកវ៉ិចទ័រលក្ខណៈជាគំរូ និងប្រើការអ៊ិនកូដអុហ្វសិតសម្រាប់ភាពអាស្រ័យរវាងវ៉ិចទ័រលក្ខណៈ)

ហេតុអ្វីបានជាអ្នកលុប HMMs ចេញពី scikit-learn?
សូមមើល:ref:`adding_graphical_models`។

តើអ្នកនឹងបន្ថែមការគាំទ្រ GPU ទេ?
ទេ ឬយ៉ាងហោចណាស់ក៏មិនមែននាពេលខាងមុខដែរ។ មូលហេតុចម្បងគឺថាការគាំទ្រ GPU នឹងណែនាំភាពអាស្រ័យកម្មវិធីជាច្រើន និងណែនាំបញ្ហាជាក់លាក់នៃវេទិកា។ scikit-learn ត្រូវបានរចនាឡើងដើម្បីងាយស្រួលដំឡើងនៅលើវេទិកាជាច្រើនប្រភេទ។ នៅខាងក្រៅបណ្តាញសរសៃប្រសាទ GPUs មិនដើរតួនាទីធំនៅក្នុងការរៀនម៉ាស៊ីននាពេលបច្ចុប្បន្ននេះទេ ហើយការបង្កើនល្បឿនកាន់តែច្រើនជាញឹកញាប់អាចសម្រេចបានដោយជម្រើសដ៏ប្រុងប្រយ័ត្ននៃក្បួនដោះស្រាយ។

ហេតុអ្វីបានជាអថេរ categorical ត្រូវការដំណើរការជាមុននៅក្នុង scikit-learn បើប្រៀបធៀបទៅនឹងឧបករណ៍ផ្សេងទៀត?
ភាគច្រើននៃ scikit-learn សន្មត់ថាទិន្នន័យគឺនៅក្នុង NumPy arrays ឬ SciPy sparse matrices នៃ dtype លេខតែមួយ។ ទាំងនេះមិនតំណាងឱ្យអថេរប្រភេទជាក់លាក់ទេនាពេលបច្ចុប្បន្ន។ ដូច្នេះ មិនដូច R's data.frames ឬ pandas.DataFrame ទេ យើងទាមទារឱ្យមានការបំប្លែងជាក់លាក់នៃលក្ខណៈជាក្រុមទៅជាតម្លៃលេខ ដូចដែលបានពិភាក្សានៅក្នុង :ref:`preprocessing_categorical_features`។ សូមមើលផងដែរ :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py` សម្រាប់ឧទាហរណ៍នៃការធ្វើការជាមួយទិន្នន័យផ្សេងៗគ្នា (ឧ. ប្រភេទ និងលេខ)។

ហេតុអ្វីបានជា Scikit-learn មិនដំណើរការដោយផ្ទាល់ជាមួយឧទាហរណ៍ pandas.DataFrame?
វត្ថុទិន្នន័យ NumPy និង SciPy ដូចគ្នាដែលរំពឹងទុកនាពេលបច្ចុប្បន្នគឺមានប្រសិទ្ធភាពបំផុតក្នុងដំណើរការសម្រាប់ប្រតិបត្តិការភាគច្រើន។ ការងារដ៏ទូលំទូលាយក៏នឹងត្រូវការចាំបាច់ផងដែរ ដើម្បីគាំទ្រប្រភេទសត្វខ្លាឃ្មុំផេនដា។ ការរឹតបន្តឹងការបញ្ចូលទៅក្នុងប្រភេទដូចគ្នា ដូច្នេះកាត់បន្ថយការចំណាយលើការថែទាំ និងលើកទឹកចិត្តដល់ការប្រើប្រាស់រចនាសម្ព័ន្ធទិន្នន័យប្រកបដោយប្រសិទ្ធភាព។

ចំណាំថា :class:`~sklearn.compose.ColumnTransformer` ធ្វើឱ្យវាមានភាពងាយស្រួលក្នុងការគ្រប់គ្រងទិន្នន័យស៊ុមផេនដាដែលខុសពីគ្នាដោយការគូសផែនទីសំណុំរងដូចគ្នានៃជួរឈរស៊ុមទិន្នន័យដែលបានជ្រើសរើសតាមឈ្មោះ ឬ dtype ទៅឧបករណ៍បំលែង scikit-learn ឧទ្ទិស។

ដូច្នេះ :class:`~sklearn.compose.ColumnTransformer` ជាញឹកញាប់ត្រូវបានគេប្រើនៅក្នុងជំហានដំបូងនៃបំពង់បង្ហូរប្រេង scikit-learn នៅពេលដោះស្រាយជាមួយស៊ុមទិន្នន័យផ្សេងៗគ្នា (សូមមើល: ref:`pipeline` សម្រាប់ព័ត៌មានលម្អិតបន្ថែម)។

សូមមើលផងដែរ :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py` សម្រាប់ឧទាហរណ៍នៃការធ្វើការជាមួយទិន្នន័យផ្សេងៗគ្នា (ឧ. ប្រភេទ និងលេខ)។

តើអ្នកមានគម្រោងអនុវត្តការបំប្លែងសម្រាប់គោលដៅ y នៅក្នុងបំពង់ទេ?
បច្ចុប្បន្នការបំប្លែងដំណើរការសម្រាប់តែមុខងារ X នៅក្នុងបំពង់ប៉ុណ្ណោះ។ មានការពិភាក្សាជាយូរយារណាស់មកហើយអំពីការមិនអាចបំលែង y នៅក្នុងបំពង់បង្ហូរបាន។ តាមដានបញ្ហា Github #4143។ ទន្ទឹមនឹងនេះ សូមពិនិត្យមើល :class:`~compose.TransformedTargetRegressor`, pipegraph, imbalanced-learn។ ចំណាំថា Scikit-learn បានដោះស្រាយសម្រាប់ករណីដែល y មានការផ្លាស់ប្តូរបញ្ច្រាសដែលបានអនុវត្តមុនពេលបណ្តុះបណ្តាល និងដាក់បញ្ច្រាសបន្ទាប់ពីការទស្សន៍ទាយ។ Scikit-learn មានបំណងដោះស្រាយសម្រាប់ករណីប្រើប្រាស់ដែល y គួរតែត្រូវបានបំប្លែងនៅពេលហ្វឹកហាត់ និងមិនមែននៅពេលសាកល្បង សម្រាប់ការយកគំរូឡើងវិញ និងការប្រើប្រាស់ស្រដៀងគ្នា ដូចជានៅ imbalanced-learn ជាដើម។ ជាទូទៅ ករណីប្រើប្រាស់ទាំងនេះអាចត្រូវបានដោះស្រាយដោយប្រើឧបករណ៍ប៉ាន់ស្មានមេតាផ្ទាល់ខ្លួន ជាជាងបំពង់

ហេតុអ្វីបានជាមានការប៉ាន់ប្រមាណខុសៗគ្នាជាច្រើនសម្រាប់ម៉ូដែលលីនេអ៊ែរ?
ជាធម្មតាមានអ្នកចាត់ថ្នាក់មួយ និងឧបករណ៍តំរែតំរង់មួយក្នុងមួយប្រភេទគំរូ ឧ. :class:`~ensemble.GradientBoostingClassifier` និង :class:`~ensemble.GradientBoostingRegressor`។ ទាំងពីរមានជម្រើសស្រដៀងគ្នា ហើយទាំងពីរមានការបាត់បង់ប៉ារ៉ាម៉ែត្រ ដែលមានប្រយោជន៍ជាពិសេសនៅក្នុងករណីតំរែតំរង់ព្រោះវាអនុញ្ញាតឱ្យមានការប៉ាន់ប្រមាណនៃមធ្យមតាមលក្ខខណ្ឌ ក៏ដូចជាបរិមាណតាមលក្ខខណ្ឌ។

សម្រាប់ម៉ូដែលលីនេអ៊ែរ មានថ្នាក់ប៉ាន់ស្មានជាច្រើនដែលនៅជិតគ្នាទៅវិញទៅមក។ សូម​ឲ្យ​យើង​ពិនិត្យ​មើល

:class:`~linear_model.LinearRegression`, គ្មានការពិន័យទេ។
:class:`~linear_model.Ridge`, L2 ពិន័យ
:class:`~linear_model.Lasso`, L1 ពិន័យ (គំរូតូច)
:class:`~linear_model.ElasticNet`, L1 + L2 ពិន័យ (ម៉ូដែលមិនសូវល្អ)
:class:`~linear_model.SGDRegressor` with loss='squared_loss'
ទស្សនៈអ្នកថែទាំ៖ ពួកគេទាំងអស់ធ្វើដូចគ្នាក្នុងគោលការណ៍ ហើយខុសគ្នាតែដោយការពិន័យដែលពួកគេដាក់។ យ៉ាង​ណា​មិញ នេះ​មាន​ផល​ប៉ះ​ពាល់​យ៉ាង​ខ្លាំង​លើ​វិធី​ដែល​បញ្ហា​បង្កើន​ប្រសិទ្ធភាព​មូលដ្ឋាន​ត្រូវ​បាន​ដោះ​ស្រាយ។ នៅទីបញ្ចប់ នេះស្មើនឹងការប្រើប្រាស់វិធីសាស្រ្ត និងល្បិចផ្សេងៗពីពិជគណិតលីនេអ៊ែរ។ ករណីពិសេសមួយគឺ SGDRegressor ដែលរួមមានទាំង 4 ម៉ូដែលមុន និងខុសគ្នាដោយនីតិវិធីបង្កើនប្រសិទ្ធភាព។ ផលរំខានមួយទៀតគឺថាអ្នកប៉ាន់ស្មានផ្សេងគ្នាអនុគ្រោះដល់ប្លង់ទិន្នន័យផ្សេងៗគ្នា (X c-ជាប់គ្នា ឬ f-ជាប់គ្នា ស៊ីស ស៊ីស ឬ ស៊ីអេសស៊ី) ។ ភាពស្មុគស្មាញនៃគំរូលីនេអ៊ែរដែលហាក់ដូចជាសាមញ្ញនេះគឺជាហេតុផលសម្រាប់ការមានថ្នាក់ប៉ាន់ស្មានផ្សេងៗគ្នាសម្រាប់ការពិន័យផ្សេងៗគ្នា។

ទស្សនវិស័យរបស់អ្នកប្រើ៖ ទីមួយ ការរចនាបច្ចុប្បន្នត្រូវបានបំផុសគំនិតដោយអក្សរសិល្ប៍វិទ្យាសាស្ត្រ ដែលគំរូតំរែតំរង់លីនេអ៊ែរដែលមានភាពទៀងទាត់/ការពិន័យខុសៗគ្នាត្រូវបានគេផ្តល់ឈ្មោះខុសៗគ្នា ឧ. តំរែតំរង់ជួរ។ ការ​មាន​ថ្នាក់​គំរូ​ខុស​គ្នា​ជាមួយ​នឹង​ឈ្មោះ​ធ្វើ​ឱ្យ​អ្នក​ប្រើ​ងាយ​ស្រួល​ក្នុង​ការ​ស្វែង​រក​គំរូ​តំរែតំរង់​ទាំង​នោះ។ ទីពីរ ប្រសិនបើម៉ូដែលលីនេអ៊ែរទាំង 5 ដែលបានរៀបរាប់ខាងលើត្រូវបានបង្រួបបង្រួមទៅក្នុងថ្នាក់តែមួយ នោះនឹងមានប៉ារ៉ាម៉ែត្រដែលមានជម្រើសជាច្រើនដូចជាប៉ារ៉ាម៉ែត្រដំណោះស្រាយ។ លើសពីនេះ វានឹងមានអន្តរកម្មផ្តាច់មុខជាច្រើនរវាងប៉ារ៉ាម៉ែត្រផ្សេងៗគ្នា។ ឧទាហរណ៍ ជម្រើសដែលអាចធ្វើបាននៃប៉ារ៉ាម៉ែត្រដោះស្រាយ ការកំណត់ជាមុន និងការជ្រើសរើសនឹងអាស្រ័យលើតម្លៃដែលបានជ្រើសរើសនៃប៉ារ៉ាម៉ែត្រពិន័យ alpha និង l1_ratio។

ការរួមចំណែក
តើខ្ញុំអាចចូលរួមចំណែកក្នុងការរៀន scikit យ៉ាងដូចម្តេច?
សូមមើល:ref:`ការរួមចំណែក`។ មុនពេលចង់បន្ថែមក្បួនដោះស្រាយថ្មី ដែលជាធម្មតាជាកិច្ចការធំ និងវែង វាត្រូវបានណែនាំឱ្យចាប់ផ្តើមជាមួយ :ref:`បញ្ហាដែលគេស្គាល់ <new_contributors>`។ សូមកុំទាក់ទងអ្នករួមចំណែកនៃ scikit-learn ដោយផ្ទាល់ទាក់ទងនឹងការរួមចំណែកដល់ scikit-learn ។

ហេតុអ្វីបានជាសំណើរទាញរបស់ខ្ញុំមិនទទួលបានការចាប់អារម្មណ៍?
ដំណើរការពិនិត្យ scikit-learn ត្រូវការពេលវេលាច្រើន ហើយអ្នករួមចំណែកមិនគួរត្រូវបានបាក់ទឹកចិត្តដោយសារកង្វះសកម្មភាព ឬការពិនិត្យឡើងវិញលើសំណើទាញរបស់ពួកគេ។ យើងយកចិត្តទុកដាក់យ៉ាងខ្លាំងចំពោះការទទួលបានរបស់ត្រឹមត្រូវជាលើកដំបូង ដោយសារការថែទាំ និងការផ្លាស់ប្តូរនៅពេលក្រោយមានការចំណាយខ្ពស់។ យើងកម្រនឹងបញ្ចេញលេខកូដ "ពិសោធន៍" ណាស់ ដូច្នេះការរួមចំណែករបស់យើងទាំងអស់នឹងត្រូវប្រើប្រាស់យ៉ាងខ្ពស់ភ្លាមៗ ហើយគួរតែមានគុណភាពខ្ពស់បំផុតដែលអាចធ្វើទៅបានដំបូង។

លើសពីនេះ scikit-learn ត្រូវបានកំណត់នៅក្នុងកម្រិតបញ្ជូនពិនិត្យឡើងវិញរបស់វា។ អ្នកត្រួតពិនិត្យ និងអ្នកអភិវឌ្ឍន៍ស្នូលជាច្រើនកំពុងធ្វើការលើ scikit-learn នៅលើពេលវេលាផ្ទាល់ខ្លួនរបស់ពួកគេ។ ប្រសិនបើការពិនិត្យឡើងវិញលើសំណើទាញរបស់អ្នកមកយឺត វាទំនងជាដោយសារតែអ្នកត្រួតពិនិត្យរវល់។ យើងស្នើសុំការយោគយល់របស់អ្នក និងស្នើសុំកុំឱ្យអ្នកបិទសំណើរដក ឬបញ្ឈប់ការងាររបស់អ្នកដោយហេតុផលនេះ។

តើអ្វីជាលក្ខណៈវិនិច្ឆ័យនៃការដាក់បញ្ចូលសម្រាប់ក្បួនដោះស្រាយថ្មី?
យើងពិចារណាតែក្បួនដោះស្រាយដែលបានបង្កើតឡើងយ៉ាងល្អសម្រាប់ការដាក់បញ្ចូល។ ច្បាប់នៃមេដៃគឺយ៉ាងហោចណាស់ 3 ឆ្នាំចាប់តាំងពីការបោះពុម្ពផ្សាយ ការដកស្រង់ 200+ និងការប្រើប្រាស់ទូលំទូលាយ និងមានប្រយោជន៍។ បច្ចេកទេសដែលផ្តល់នូវការកែលម្អយ៉ាងច្បាស់លាស់ (ឧ. រចនាសម្ព័ន្ធទិន្នន័យដែលប្រសើរឡើង ឬបច្ចេកទេសប្រហាក់ប្រហែលដែលមានប្រសិទ្ធភាពជាង) លើវិធីសាស្ត្រដែលត្រូវបានប្រើប្រាស់យ៉ាងទូលំទូលាយក៏នឹងត្រូវបានពិចារណាសម្រាប់ការដាក់បញ្ចូលផងដែរ។

ពីក្បួនដោះស្រាយ ឬបច្ចេកទេសដែលបំពេញតាមលក្ខណៈវិនិច្ឆ័យខាងលើ មានតែអ្វីដែលសមល្អនៅក្នុង API បច្ចុប្បន្ននៃ scikit-learn ប៉ុណ្ណោះ នោះគឺជាការសម ទស្សន៍ទាយ/បំប្លែងចំណុចប្រទាក់ និងជាធម្មតាមានធាតុបញ្ចូល/លទ្ធផល ដែលជាម៉ាទ្រីស numpy ឬ sparse គឺ ទទួលយក។

អ្នករួមចំណែកគួរតែគាំទ្រដល់សារៈសំខាន់នៃការបន្ថែមដែលបានស្នើឡើងជាមួយនឹងឯកសារស្រាវជ្រាវ និង/ឬការអនុវត្តនៅក្នុងកញ្ចប់ស្រដៀងគ្នាផ្សេងទៀត បង្ហាញពីអត្ថប្រយោជន៍របស់វាតាមរយៈករណីប្រើប្រាស់ទូទៅ/កម្មវិធី និងការពង្រឹងការអនុវត្តជាក់ស្តែង ប្រសិនបើមាន ដោយមានគោល និង/ឬផែនការ។ វាត្រូវបានគេរំពឹងថាក្បួនដោះស្រាយដែលបានស្នើឡើងគួរតែប្រសើរជាងវិធីសាស្ត្រដែលត្រូវបានអនុវត្តរួចហើយនៅក្នុង scikit-learn យ៉ាងហោចណាស់នៅក្នុងតំបន់មួយចំនួន។

ការដាក់បញ្ចូលនូវក្បួនដោះស្រាយថ្មីដែលបង្កើនល្បឿនគំរូដែលមានស្រាប់គឺងាយស្រួលជាងប្រសិនបើ៖

វាមិនណែនាំប៉ារ៉ាម៉ែត្រខ្ពស់ថ្មីទេ (ព្រោះវាធ្វើឱ្យបណ្ណាល័យកាន់តែភស្តុតាងនាពេលអនាគត)
វាងាយស្រួលក្នុងការចងក្រងឯកសារយ៉ាងច្បាស់នៅពេលដែលការរួមចំណែកធ្វើអោយប្រសើរឡើងនូវល្បឿន និងនៅពេលដែលវាមិនមាន ឧទាហរណ៍ "នៅពេល n_features >> n_samples",
សន្ទស្សន៍បង្ហាញយ៉ាងច្បាស់ពីការបង្កើនល្បឿន។
សូមចំណាំផងដែរថាការអនុវត្តរបស់អ្នកមិនចាំបាច់នៅក្នុង scikit-learn ដើម្បីប្រើរួមគ្នាជាមួយឧបករណ៍ scikit-learn នោះទេ។ អ្នកអាចអនុវត្តក្បួនដោះស្រាយដែលអ្នកចូលចិត្តតាមវិធីដែលត្រូវគ្នា scikit-learn បង្ហោះវាទៅ GitHub ហើយប្រាប់យើងឱ្យដឹង។ យើងនឹងរីករាយក្នុងការរាយបញ្ជីវានៅក្រោម :ref:`related_projects`។ ប្រសិនបើអ្នកមានកញ្ចប់មួយនៅលើ GitHub រួចហើយបន្ទាប់ពី scikit-learn API អ្នកក៏អាចចាប់អារម្មណ៍មើល scikit-learn-contrib ផងដែរ។

ហេតុអ្វី​បាន​ជា​អ្នក​ជ្រើសរើស​យ៉ាង​ខ្លាំង​លើ​អ្វី​ដែល​អ្នក​បញ្ចូល​ក្នុង​ក្បួន​ដោះស្រាយ​ក្នុង​ការ​សិក្សា scikit-learn?
កូដភ្ជាប់មកជាមួយតម្លៃថែទាំ ហើយយើងត្រូវធ្វើឱ្យមានតុល្យភាពនៃចំនួនកូដដែលយើងមានជាមួយនឹងទំហំនៃក្រុម (ហើយបន្ថែមលើការពិតដែលថាភាពស្មុគស្មាញធ្វើមាត្រដ្ឋានមិនស្មើគ្នាជាមួយនឹងចំនួននៃលក្ខណៈពិសេស)។ កញ្ចប់នេះពឹងផ្អែកលើអ្នកអភិវឌ្ឍន៍ស្នូលដោយប្រើពេលទំនេររបស់ពួកគេដើម្បីជួសជុលកំហុស រក្សាកូដ និងពិនិត្យមើលការរួមចំណែក។ រាល់​ក្បួន​ដោះស្រាយ​ដែល​ត្រូវ​បាន​បន្ថែម​ត្រូវ​ការ​ការ​យក​ចិត្ត​ទុក​ដាក់​នា​ពេល​អនាគត​ដោយ​អ្នក​អភិវឌ្ឍន៍ ដែល​នៅ​ពេល​នោះ​អ្នក​និពន្ធ​ដើម​អាច​នឹង​បាត់​បង់​ការ​ចាប់​អារម្មណ៍​ជា​យូរ​មក​ហើយ។ សូមមើលផងដែរ៖ ref:`new_algorithms_inclusion_criteria`។ សម្រាប់ការអានដ៏អស្ចារ្យអំពីបញ្ហាថែទាំរយៈពេលវែងនៅក្នុងកម្មវិធីប្រភពបើកចំហ សូមមើលសេចក្ដីសង្ខេបប្រតិបត្តិនៃផ្លូវ និងស្ពាន

ការប្រើប្រាស់ scikit-learn
តើអ្វីជាវិធីល្អបំផុតដើម្បីទទួលបានជំនួយលើការប្រើប្រាស់ scikit-learn?
សម្រាប់សំណួរទូទៅនៃការរៀនម៉ាស៊ីន សូមប្រើ Cross Validated ជាមួយស្លាក [machine-learning]។

សម្រាប់សំណួរអំពីការប្រើប្រាស់ scikit-learn សូមប្រើ Stack Overflow ជាមួយនឹងស្លាក [scikit-learn] និង [python] ។ អ្នកក៏អាចប្រើបញ្ជីសំបុត្ររួម។

សូមប្រាកដថា រួមបញ្ចូលព័ត៌មានខ្លីៗនៃកូដបង្កើតឡើងវិញតិចតួច (តាមឧត្ដមគតិខ្លីជាង 10 បន្ទាត់) ដែលបង្ហាញពីបញ្ហារបស់អ្នកនៅលើសំណុំទិន្នន័យរបស់ក្មេងលេង (ឧទាហរណ៍ពី sklearn.datasets ឬបង្កើតដោយចៃដន្យជាមួយមុខងារ numpy.random ជាមួយនឹងគ្រាប់ពូជចៃដន្យថេរ)។ សូមលុបបន្ទាត់កូដណាមួយដែលមិនចាំបាច់ ដើម្បីបង្កើតបញ្ហារបស់អ្នកឡើងវិញ។

បញ្ហាគួរតែអាចផលិតឡើងវិញបានដោយគ្រាន់តែចម្លង-បិទភ្ជាប់ព័ត៌មានកូដរបស់អ្នកនៅក្នុងសែល Python ជាមួយនឹងការដំឡើង scikit-learn ។ កុំភ្លេចបញ្ចូលរបាយការណ៍នាំចូល។

ការណែនាំបន្ថែមក្នុងការសរសេរអត្ថបទកូដបន្តពូជល្អអាចរកបាននៅ៖

https://stackoverflow.com/help/mcve

ប្រសិនបើបញ្ហារបស់អ្នកលើកករណីលើកលែងដែលអ្នកមិនយល់ (សូម្បីតែបន្ទាប់ពីហ្គូហ្គលវាក៏ដោយ) សូមប្រាកដថាត្រូវបញ្ចូលការតាមដានពេញលេញដែលអ្នកទទួលបាននៅពេលដំណើរការស្គ្រីបផលិតឡើងវិញ។

សម្រាប់របាយការណ៍កំហុស ឬសំណើមុខងារ សូមប្រើកម្មវិធីតាមដានបញ្ហានៅលើ GitHub ។

វាក៏មានបណ្តាញ scikit-learn Gitter ដែលអ្នកប្រើប្រាស់ និងអ្នកអភិវឌ្ឍន៍មួយចំនួនអាចត្រូវបានរកឃើញ។

សូម​កុំ​ផ្ញើ​អ៊ីមែល​ទៅ​អ្នក​និពន្ធ​ណា​មួយ​ដោយ​ផ្ទាល់​ដើម្បី​សុំ​ជំនួយ រាយការណ៍​កំហុស ឬ​សម្រាប់​បញ្ហា​ផ្សេង​ទៀត​ដែល​ទាក់ទង​នឹង scikit-learn។

តើខ្ញុំគួររក្សាទុក នាំចេញ ឬដាក់ពង្រាយការប៉ាន់ប្រមាណសម្រាប់ផលិតកម្មយ៉ាងដូចម្តេច?
សូមមើល:ref:`model_persistence`។

តើខ្ញុំអាចបង្កើតវត្ថុបណ្តុំដោយរបៀបណា?
ជួនកាលវត្ថុ Bunch ត្រូវបានប្រើជាលទ្ធផលសម្រាប់មុខងារ និងវិធីសាស្ត្រ។ ពួកវាពង្រីកវចនានុក្រមដោយបើកឱ្យតម្លៃចូលប្រើដោយ key, bunch["value_key"] ឬដោយគុណលក្ខណៈ bunch.value_key ។

ពួកគេមិនគួរត្រូវបានប្រើជាការបញ្ចូល; ដូច្នេះអ្នកស្ទើរតែមិនចាំបាច់បង្កើតវត្ថុ Bunch ទេ លុះត្រាតែអ្នកកំពុងពង្រីក API របស់ scikit-learn ។

តើខ្ញុំអាចផ្ទុកសំណុំទិន្នន័យផ្ទាល់ខ្លួនរបស់ខ្ញុំទៅជាទម្រង់ដែលអាចប្រើបានដោយ scikit-learn យ៉ាងដូចម្តេច?
ជាទូទៅ scikit-learn ដំណើរការលើទិន្នន័យជាលេខណាមួយដែលរក្សាទុកជាអារេ numpy ឬ scipy sparse matrices ។ ប្រភេទផ្សេងទៀតដែលអាចបំប្លែងទៅជាអារេលេខដូចជាផេនដា DataFrame ក៏អាចទទួលយកបានផងដែរ។

សម្រាប់ព័ត៌មានបន្ថែមអំពីការផ្ទុកឯកសារទិន្នន័យរបស់អ្នកទៅក្នុងរចនាសម្ព័ន្ធទិន្នន័យដែលអាចប្រើប្រាស់បានទាំងនេះ សូមមើល :ref:`loading external datasets <external_datasets>`។

តើខ្ញុំដោះស្រាយជាមួយទិន្នន័យខ្សែអក្សរ (ឬដើមឈើ ក្រាហ្វ...) យ៉ាងដូចម្តេច?
អ្នកប៉ាន់ស្មាន scikit-learn សន្មត់ថាអ្នកនឹងចិញ្ចឹមពួកគេនូវលក្ខណៈវ៉ិចទ័រដែលមានតម្លៃពិតប្រាកដ។ ការសន្មត់នេះគឺពិបាកសរសេរនៅក្នុងបណ្ណាល័យស្ទើរតែទាំងអស់។ ទោះជាយ៉ាងណាក៏ដោយ អ្នកអាចផ្តល់ការបញ្ចូលដែលមិនមែនជាលេខទៅកាន់អ្នកប៉ាន់ស្មានតាមវិធីជាច្រើន។

ប្រសិនបើអ្នកមានឯកសារអត្ថបទ អ្នកអាចប្រើលក្ខណៈប្រេកង់ពាក្យ។ សូមមើល :ref:`text_feature_extraction` សម្រាប់វ៉ិចទ័រអត្ថបទដែលភ្ជាប់មកជាមួយ។ សម្រាប់ការទាញយកលក្ខណៈទូទៅបន្ថែមពីប្រភេទទិន្នន័យណាមួយ សូមមើល:ref:`dict_feature_extraction` និង :ref:`feature_hashing`។

ករណីទូទៅមួយទៀតគឺនៅពេលដែលអ្នកមានទិន្នន័យដែលមិនមែនជាលេខ និងមាត្រដ្ឋានចម្ងាយផ្ទាល់ខ្លួន (ឬភាពស្រដៀងគ្នា) នៅលើទិន្នន័យទាំងនេះ។ ឧទាហរណ៍រួមមានខ្សែអក្សរដែលមានចម្ងាយកែសម្រួល (aka. Levenshtein distance; ឧ. លំដាប់ DNA ឬ RNA)។ ទាំង​នេះ​អាច​ត្រូវ​បាន​បំប្លែង​ជា​លេខ ប៉ុន្តែ​ការ​ធ្វើ​ដូច្នេះ​គឺ​ជា​ការ​ឈឺចាប់ និង​ងាយ​នឹង​មាន​កំហុស។ ការធ្វើការជាមួយរង្វាស់ចម្ងាយនៅលើទិន្នន័យបំពានអាចត្រូវបានអនុវត្តតាមពីរវិធី។

ទីមួយ អ្នកប៉ាន់ស្មានជាច្រើនយកម៉ាទ្រីសចម្ងាយ/ភាពស្រដៀងគ្នាដែលបានគណនាជាមុន ដូច្នេះប្រសិនបើសំណុំទិន្នន័យមិនធំពេក អ្នកអាចគណនាចម្ងាយសម្រាប់គូនៃធាតុបញ្ចូលទាំងអស់។ ប្រសិនបើសំណុំទិន្នន័យមានទំហំធំ អ្នកអាចប្រើលក្ខណៈវ៉ិចទ័រដែលមាន "លក្ខណៈពិសេស" តែមួយគត់ ដែលជាលិបិក្រមទៅក្នុងរចនាសម្ព័ន្ធទិន្នន័យដាច់ដោយឡែក និងផ្គត់ផ្គង់មុខងារម៉ែត្រផ្ទាល់ខ្លួនដែលរកមើលទិន្នន័យជាក់ស្តែងនៅក្នុងរចនាសម្ព័ន្ធទិន្នន័យនេះ។ ឧ. ដើម្បីប្រើ DBSCAN ជាមួយចម្ងាយ Levenshtein៖

>>> ពី leven import levenshtein # doctest: +SKIP
>>> នាំចូល numpy ជា np
>>> ពី sklearn.cluster នាំចូល dbscan
>>> data = ["ACCTCCTAGAAG", "ACCTACTAGAAGTT", "GAATATTAGGCCGA"]
>>> def lev_metric (x, y)៖
... i, j = int(x[0]), int(y[0]) # សន្ទស្សន៍ស្រង់ចេញ
... ត្រឡប់ levenshtein(ទិន្នន័យ[i], ទិន្នន័យ[j])
...
>>> X = np.arange(len(data)).reshape(-1, 1)
>>> X
អារេ([[0],
        [1],
        [2]])
>>> # យើងត្រូវបញ្ជាក់ algorithm='brute' ជាលំនាំដើមសន្មត់
>>> # ចន្លោះមុខងារបន្ត។
>>> dbscan(X, metric=lev_metric, eps=5, min_samples=2, algorithm='brute')
... # doctest: +SKIP
([0, 1], អារេ([0, 0, -1]))
(វាប្រើ leven កញ្ចប់ចម្ងាយកែសម្រួលភាគីទីបី។ )

ល្បិចស្រដៀងគ្នានេះអាចត្រូវបានប្រើ ដោយមានការប្រុងប្រយ័ត្នខ្លះ សម្រាប់ខឺណែលមែកធាង ខឺណែលក្រាហ្វ។ល។

ហេតុអ្វីបានជាពេលខ្លះខ្ញុំមានការគាំង/បង្កកជាមួយ n_jobs> 1 នៅក្រោម OSX ឬ Linux?
ឧបករណ៍ scikit-learn ជាច្រើនដូចជា GridSearchCV និង cross_val_score ពឹងផ្អែកលើម៉ូឌុលដំណើរការច្រើនរបស់ Python ដើម្បីដំណើរការស្របគ្នាលើដំណើរការ Python ជាច្រើនដោយឆ្លងកាត់ n_jobs > 1 ជាអាគុយម៉ង់មួយ។

បញ្ហាគឺថា Python multiprocessing ធ្វើការហៅប្រព័ន្ធ fork ដោយមិនធ្វើតាមវាជាមួយនឹងការហៅប្រព័ន្ធ exec សម្រាប់ហេតុផលដំណើរការ។ បណ្ណាល័យជាច្រើនដូចជា (កំណែមួយចំនួននៃ) Accelerate / vecLib នៅក្រោម OSX, (កំណែមួយចំនួននៃ) MKL, OpenMP runtime របស់ GCC, Nvidia's Cuda (និងប្រហែលជាជាច្រើនទៀត) គ្រប់គ្រងការបញ្ចូលខ្សែស្រឡាយខាងក្នុងរបស់ពួកគេ។ នៅពេលមានការហៅទៅសម ស្ថានភាពនៃបណ្តុំខ្សែស្រឡាយនៅក្នុងដំណើរការកុមារត្រូវបានខូច៖ បណ្តុំខ្សែស្រឡាយជឿថាវាមានខ្សែស្រឡាយជាច្រើន ខណៈដែលមានតែស្ថានភាពខ្សែស្រឡាយសំខាន់ប៉ុណ្ណោះដែលត្រូវបានបំបែក។ វាអាចទៅរួចក្នុងការផ្លាស់ប្តូរបណ្ណាល័យដើម្បីធ្វើឱ្យពួកវារកឃើញនៅពេលដែលសមកើតឡើង និងចាប់ផ្តើមឡើងវិញនូវបណ្តុំខ្សែស្រឡាយនៅក្នុងករណីនោះ៖ យើងបានធ្វើវាសម្រាប់ OpenBLAS (បញ្ចូលចូលគ្នាក្នុងមេតាំងពី 0.2.10) ហើយយើងបានរួមចំណែកបំណះមួយទៅពេលវេលាដំណើរការ OpenMP របស់ GCC (មិនមែន នៅតែពិនិត្យ) ។

ប៉ុន្តែនៅទីបញ្ចប់ ពិរុទ្ធជនពិតប្រាកដគឺដំណើរការពហុដំណើរការរបស់ Python ដែលធ្វើការបំបែកដោយគ្មាន exec ដើម្បីកាត់បន្ថយការចំណាយលើការចាប់ផ្តើម និងប្រើប្រាស់ដំណើរការ Python ថ្មីសម្រាប់ការគណនាប៉ារ៉ាឡែល។ ជាអកុសល នេះគឺជាការរំលោភលើស្តង់ដារ POSIX ដូច្នេះហើយ អ្នកកែសម្រួលកម្មវិធីមួយចំនួនដូចជា Apple បដិសេធមិនពិចារណាអំពីកង្វះសុវត្ថិភាព fork ក្នុង Accelerate / vecLib ជាកំហុស។

នៅក្នុង Python 3.4+ ឥឡូវនេះវាអាចធ្វើទៅបានដើម្បីកំណត់រចនាសម្ព័ន្ធដំណើរការច្រើនដើម្បីប្រើវិធីសាស្ត្រចាប់ផ្តើម 'forkserver' ឬ 'spawn' (ជំនួសឱ្យ 'fork' លំនាំដើម) ដើម្បីគ្រប់គ្រងដំណើរការ។ ដើម្បីដោះស្រាយបញ្ហានេះនៅពេលប្រើ scikit-learn អ្នកអាចកំណត់អថេរបរិស្ថាន JOBLIB_START_METHOD ទៅ 'forkserver'។ ទោះយ៉ាងណាក៏ដោយ អ្នកប្រើប្រាស់គួរតែដឹងថាការប្រើវិធីសាស្ត្រ 'forkserver' រារាំង joblib.Parallel ដើម្បីហៅមុខងារដែលកំណត់ដោយអន្តរកម្មនៅក្នុងវគ្គសែល។

ប្រសិនបើអ្នកមានកូដផ្ទាល់ខ្លួនដែលប្រើការដំណើរការច្រើនដោយផ្ទាល់ជំនួសឱ្យការប្រើវាតាមរយៈ joblib អ្នកអាចបើករបៀប 'forkserver' ជាសកលសម្រាប់កម្មវិធីរបស់អ្នក៖ បញ្ចូលការណែនាំខាងក្រោមនៅក្នុងស្គ្រីបចម្បងរបស់អ្នក៖

នាំចូលពហុដំណើរការ

# ការនាំចូលផ្សេងទៀត កូដផ្ទាល់ខ្លួន ផ្ទុកទិន្នន័យ កំណត់ម៉ូដែល...

ប្រសិនបើ __name__ == '__main__':
     multiprocessing.set_start_method('forkserver')

     # ហៅឧបករណ៍ប្រើប្រាស់ scikit-learn ជាមួយ n_jobs > 1 នៅទីនេះ
អ្នកអាចស្វែងរកលំនាំដើមបន្ថែមទៀតនៅលើវិធីសាស្ត្រចាប់ផ្តើមថ្មីនៅក្នុងឯកសារដំណើរការពហុ។

ហេតុអ្វីបានជាការងាររបស់ខ្ញុំប្រើស្នូលច្រើនជាងអ្វីដែលបានបញ្ជាក់ជាមួយ n_jobs?
នេះគឺដោយសារតែ n_jobs គ្រប់គ្រងតែចំនួនការងារសម្រាប់ទម្លាប់ដែលត្រូវបានប៉ារ៉ាឡែលជាមួយ joblib ប៉ុន្តែលេខកូដប៉ារ៉ាឡែលអាចមកពីប្រភពផ្សេងទៀត៖

ទម្លាប់ខ្លះអាចស្របគ្នាជាមួយ OpenMP (សម្រាប់កូដសរសេរជា C ឬ Cython)។
scikit-learn ពឹងផ្អែកច្រើនលើ numpy ដែលនៅក្នុងវេនអាចពឹងផ្អែកលើបណ្ណាល័យលេខដូចជា MKL, OpenBLAS ឬ BLIS ដែលអាចផ្តល់នូវការអនុវត្តស្របគ្នា។
សម្រាប់ព័ត៌មានលម្អិត សូមមើល :ref:`កំណត់ចំណាំ Parallelism <parallelism>` របស់យើង។

តើខ្ញុំកំណត់ Random_state សម្រាប់ការប្រតិបត្តិទាំងមូលដោយរបៀបណា?
សូមយោងទៅ៖ ref:`ចៃដន្យ`។